## 			操作系统单双核使用方法

> * SDK默认运行双核操作系统的方法, 所有就绪任务按照哪个核心空闲分配到哪个核心调度的策略运行;
>
>   
>
> * 在某些情况,用户增加的功能对CPU占据特别大,或者对时序要求特别苛刻,可以把双核分开使用, 一个核跑操作系统,另外一个核专门跑用户功能,配置方法如下:
>
>   1.修改 include_lib\driver\cpu\对应cpu目录\asm\cpu.h的宏定义 #define CPU_CORE_NUM     1
>
>   2.寻求杰理技术团队替换单核专用的system.a库
>
>   3.在 app_main.c的 irq_info_table 显式增加需要安装到核1的中断,其余没有显式增加的中断会全部安装到核0
>
>   4.最后核0运行操作系统, 核1运行到cpu1_main,用户可以在此增加功能
>
>   
>

## 常见问题

> * cpu1_main是否可以调用操作系统接口？
>
>   答：不可以,并且printf/puts等打印接口内部也用到操作系统接口,因此也不可以, 调试过程中可以加入打印,但是会有概率引发概率性死机
>
>   
>
> * 核0和核1如何互斥？
>
>   答：使用spin_lock
>
>   
>
> * cpu1_main 函数的 __asm__ volatile("idle"); 有什么作用?
>
>   答:是为了让cpu1休闲降低功耗,但是如果cpu1没有中断触发,会导致cpu1停止运行,用户根据情况要不要删除掉
>
>   
>
> * 如果运行在SFC模式下,写FLASH的时候会挂起CPU1,如果不希望引起CPU1挂起,应该怎么办?
>
>   答：在 [init.c](../../../../apps/common/system/init.c)的 EnableOtherCpu();后面增加一句话 cpu1_run_flag = 0;
>   	但是需要保证cpu1_main调用到的所有函数全部放到内部ram或者sdram,防止写flash过程中引起死机

## 参考文档

> * [库代码定位到指定段方法](../../../../apps/common/example/库代码定位到指定段方法/readme.md)
> * [指定函数到芯片指定内存方法](../../../../apps/common/example/芯片内存使用)

